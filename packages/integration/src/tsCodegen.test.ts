import type { IntegrationContext } from './types'
import { beforeEach, describe, expect, it, vi } from 'vitest'
import { generateTsCodegenContent } from './tsCodegen'

function createMockCtx(overrides: Partial<Pick<IntegrationContext, 'currentPackageName' | 'fnName' | 'transformedFormat' | 'hasVue' | 'engine' | 'usages'>> = {}): IntegrationContext {
	return {
		currentPackageName: '@pikacss/core',
		fnName: 'pika',
		transformedFormat: 'string',
		hasVue: false,
		engine: {
			config: {
				autocomplete: {
					selectors: new Set(['hover']),
					styleItemStrings: new Set(['flex-center']),
					extraProperties: new Set(['__important']),
					extraCssProperties: new Set(['--color']),
					properties: new Map([['__important', ['boolean']]]),
					cssProperties: new Map([['color', ['red', 'blue']]]),
				},
				layers: {},
			},
			renderAtomicStyles: vi.fn()
				.mockResolvedValue('.a { color: red; }'),
		},
		usages: new Map(),
		...overrides,
	} as unknown as IntegrationContext
}

function createMockCtxForTsCodegen(overrides: {
	layers?: Record<string, number>
} = {}): IntegrationContext {
	return {
		currentPackageName: '@pikacss/test',
		fnName: 'pika',
		transformedFormat: 'string',
		hasVue: false,
		engine: {
			config: {
				autocomplete: {
					selectors: new Set(),
					styleItemStrings: new Set(),
					extraProperties: new Set(),
					extraCssProperties: new Set(),
					properties: new Map(),
					cssProperties: new Map(),
				},
				layers: overrides.layers ?? {},
			},
			renderAtomicStyles: vi.fn()
				.mockResolvedValue(''),
		},
		usages: new Map(),
	} as unknown as IntegrationContext
}

describe('generateTsCodegenContent', () => {
	it('should generate import statement with correct package name', async () => {
		const ctx = createMockCtx()
		const result = await generateTsCodegenContent(ctx)
		expect(result)
			.toContain(`// Auto-generated by @pikacss/core`)
		expect(result)
			.toContain(`import type { CSSProperty, CSSSelector, DefineAutocomplete, Properties, StyleDefinition, StyleItem } from '@pikacss/core'`)
	})

	it('should generate import statement with custom package name', async () => {
		const ctx = createMockCtx({ currentPackageName: '@pikacss/custom' })
		const result = await generateTsCodegenContent(ctx)
		expect(result)
			.toContain(`// Auto-generated by @pikacss/custom`)
		expect(result)
			.toContain(`from '@pikacss/custom'`)
	})

	it('should include Autocomplete type definition', async () => {
		const ctx = createMockCtx()
		const result = await generateTsCodegenContent(ctx)
		expect(result)
			.toContain('export type Autocomplete = DefineAutocomplete<{')
		expect(result)
			.toContain(`Selector: "hover"`)
		expect(result)
			.toContain(`StyleItemString: "flex-center"`)
		expect(result)
			.toContain(`ExtraProperty: "__important"`)
		expect(result)
			.toContain(`ExtraCssProperty: "--color"`)
		expect(result)
			.toContain(`PropertiesValue: { '__important': boolean }`)
		expect(result)
			.toContain(`CssPropertiesValue: { 'color': "red" | "blue" }`)
		expect(result)
			.toContain('Layer: never')
	})

	it('should generate Autocomplete with empty sets as never', async () => {
		const ctx = createMockCtx({
			engine: {
				config: {
					autocomplete: {
						selectors: new Set(),
						styleItemStrings: new Set(),
						extraProperties: new Set(),
						extraCssProperties: new Set(),
						properties: new Map(),
						cssProperties: new Map(),
					},
					layers: {},
				},
				renderAtomicStyles: vi.fn()
					.mockResolvedValue(''),
			} as unknown as IntegrationContext['engine'],
		})
		const result = await generateTsCodegenContent(ctx)
		expect(result)
			.toContain('Selector: never')
		expect(result)
			.toContain('StyleItemString: never')
		expect(result)
			.toContain('ExtraProperty: never')
		expect(result)
			.toContain('ExtraCssProperty: never')
	})

	it('should generate StyleFn types for string format', async () => {
		const ctx = createMockCtx({ transformedFormat: 'string' })
		const result = await generateTsCodegenContent(ctx)
		expect(result)
			.toContain('type StyleFn_Normal = StyleFn_String')
		expect(result)
			.toContain('type StyleFn_Array = (...params: StyleItem[]) => string[]')
		expect(result)
			.toContain('type StyleFn_String = (...params: StyleItem[]) => string')
		expect(result)
			.toContain('type StyleFn_Inline = (...params: StyleItem[]) => void')
	})

	it('should generate StyleFn types for array format', async () => {
		const ctx = createMockCtx({ transformedFormat: 'array' })
		const result = await generateTsCodegenContent(ctx)
		expect(result)
			.toContain('type StyleFn_Normal = StyleFn_Array')
	})

	it('should generate StyleFn types for inline format', async () => {
		const ctx = createMockCtx({ transformedFormat: 'inline' })
		const result = await generateTsCodegenContent(ctx)
		expect(result)
			.toContain('type StyleFn_Normal = StyleFn_Inline')
	})

	it('should generate StyleFn with str, arr, inl accessors', async () => {
		const ctx = createMockCtx()
		const result = await generateTsCodegenContent(ctx)
		expect(result)
			.toContain('type StyleFn = StyleFn_Normal & {')
		expect(result)
			.toContain('str: StyleFn_String')
		expect(result)
			.toContain('arr: StyleFn_Array')
		expect(result)
			.toContain('inl: StyleFn_Inline')
	})

	it('should generate global declaration with fnName', async () => {
		const ctx = createMockCtx({ fnName: 'pika' })
		const result = await generateTsCodegenContent(ctx)
		expect(result)
			.toContain('declare global {')
		expect(result)
			.toContain('const pika: StyleFn')
		expect(result)
			.toContain('const pikap: StyleFnWithPreview')
	})

	it('should generate global declaration with custom fnName', async () => {
		const ctx = createMockCtx({ fnName: 'css' })
		const result = await generateTsCodegenContent(ctx)
		expect(result)
			.toContain('const css: StyleFn')
		expect(result)
			.toContain('const cssp: StyleFnWithPreview')
	})

	it('should omit Vue declaration when hasVue is false', async () => {
		const ctx = createMockCtx({ hasVue: false })
		const result = await generateTsCodegenContent(ctx)
		expect(result).not.toContain('declare module \'vue\'')
		expect(result).not.toContain('ComponentCustomProperties')
	})

	it('should generate Vue declaration when hasVue is true', async () => {
		const ctx = createMockCtx({ hasVue: true, fnName: 'pika' })
		const result = await generateTsCodegenContent(ctx)
		expect(result)
			.toContain('declare module \'vue\'')
		expect(result)
			.toContain('interface ComponentCustomProperties')
		expect(result)
			.toContain('pika: StyleFn')
		expect(result)
			.toContain('pikap: StyleFnWithPreview')
	})

	it('should generate PikaAugment module declaration', async () => {
		const ctx = createMockCtx()
		const result = await generateTsCodegenContent(ctx)
		expect(result)
			.toContain('declare module \'@pikacss/core\'')
		expect(result)
			.toContain('interface PikaAugment')
		expect(result)
			.toContain('Autocomplete: Autocomplete')
	})

	it('should generate PreviewOverloads with empty usages', async () => {
		const ctx = createMockCtx({ usages: new Map() })
		const result = await generateTsCodegenContent(ctx)
		expect(result)
			.toContain('interface PreviewOverloads<StyleFn extends (StyleFn_Array | StyleFn_String | StyleFn_Inline)>')
		expect(result)
			.toContain('fn(...params: Parameters<StyleFn>): ReturnType<StyleFn>')
	})

	it('should generate PreviewOverloads with usage records', async () => {
		const usages = new Map([
			['file.ts', [
				{
					atomicStyleIds: ['a1'],
					params: [{ color: 'red' }],
				},
			]],
		])
		const mockRenderAtomicStyles = vi.fn()
			.mockResolvedValue('.a { color: red; }')
		const ctx = createMockCtx({
			usages: usages as unknown as IntegrationContext['usages'],
			engine: {
				config: {
					autocomplete: {
						selectors: new Set(['hover']),
						styleItemStrings: new Set(['flex-center']),
						extraProperties: new Set(['__important']),
						extraCssProperties: new Set(['--color']),
						properties: new Map([['__important', ['boolean']]]),
						cssProperties: new Map([['color', ['red', 'blue']]]),
					},
					layers: {},
				},
				renderAtomicStyles: mockRenderAtomicStyles,
			} as unknown as IntegrationContext['engine'],
		})
		const result = await generateTsCodegenContent(ctx)
		expect(mockRenderAtomicStyles)
			.toHaveBeenCalledWith(true, { atomicStyleIds: ['a1'], isPreview: true })
		expect(result)
			.toContain('PikaCSS Preview')
		expect(result)
			.toContain('type P0_0 =')
		expect(result)
			.toContain('fn(...params: [p0: P0_0]): ReturnType<StyleFn>')
	})

	it('should handle renderAtomicStyles errors gracefully', async () => {
		const usages = new Map([
			['file.ts', [
				{
					atomicStyleIds: ['err'],
					params: [{ color: 'bad' }],
				},
			]],
		])
		const mockRenderAtomicStyles = vi.fn()
			.mockRejectedValue(new Error('render error'))
		const ctx = createMockCtx({
			usages: usages as unknown as IntegrationContext['usages'],
			engine: {
				config: {
					autocomplete: {
						selectors: new Set(),
						styleItemStrings: new Set(),
						extraProperties: new Set(),
						extraCssProperties: new Set(),
						properties: new Map(),
						cssProperties: new Map(),
					},
					layers: {},
				},
				renderAtomicStyles: mockRenderAtomicStyles,
			} as unknown as IntegrationContext['engine'],
		})
		// Should not throw even when renderAtomicStyles rejects
		const result = await generateTsCodegenContent(ctx)
		expect(result)
			.toContain('interface PreviewOverloads')
		// The failing usage should be skipped
		expect(result).not.toContain('type P0_0 =')
	})

	it('should generate multiple usage overloads', async () => {
		const usages = new Map([
			['file.ts', [
				{
					atomicStyleIds: ['a1'],
					params: [{ color: 'red' }],
				},
				{
					atomicStyleIds: ['a2'],
					params: [{ fontSize: '16px' }, { margin: '0' }],
				},
			]],
		])
		const mockRenderAtomicStyles = vi.fn()
			.mockResolvedValue('.x { display: flex; }')
		const ctx = createMockCtx({
			usages: usages as unknown as IntegrationContext['usages'],
			engine: {
				config: {
					autocomplete: {
						selectors: new Set(),
						styleItemStrings: new Set(),
						extraProperties: new Set(),
						extraCssProperties: new Set(),
						properties: new Map(),
						cssProperties: new Map(),
					},
					layers: {},
				},
				renderAtomicStyles: mockRenderAtomicStyles,
			} as unknown as IntegrationContext['engine'],
		})
		const result = await generateTsCodegenContent(ctx)
		expect(result)
			.toContain('type P0_0 =')
		expect(result)
			.toContain('type P1_0 =')
		expect(result)
			.toContain('type P1_1 =')
		expect(result)
			.toContain('fn(...params: [p0: P0_0]): ReturnType<StyleFn>')
		expect(result)
			.toContain('fn(...params: [p0: P1_0, p1: P1_1]): ReturnType<StyleFn>')
	})

	describe('formatUnionStringType escaping via JSON.stringify', () => {
		function makeCtxWithSelectors(...selectors: string[]): IntegrationContext {
			return {
				currentPackageName: '@pikacss/test',
				fnName: 'pika',
				transformedFormat: 'string',
				hasVue: false,
				engine: {
					config: {
						autocomplete: {
							selectors: new Set(selectors),
							styleItemStrings: new Set(),
							extraProperties: new Set(),
							extraCssProperties: new Set(),
							properties: new Map(),
							cssProperties: new Map(),
						},
						layers: {},
					},
					renderAtomicStyles: vi.fn()
						.mockResolvedValue(''),
				},
				usages: new Map(),
			} as unknown as IntegrationContext
		}

		it('should escape double quotes in string values using JSON.stringify', async () => {
			const selector = '[data-value="active"]'
			const result = await generateTsCodegenContent(makeCtxWithSelectors(selector))
			expect(result)
				.toContain(`Selector: ${JSON.stringify(selector)}`)
		})

		it('should escape backslashes in string values using JSON.stringify', async () => {
			const selector = 'path\\to\\file'
			const result = await generateTsCodegenContent(makeCtxWithSelectors(selector))
			expect(result)
				.toContain(`Selector: ${JSON.stringify(selector)}`)
		})

		it('should not escape single quotes in string values', async () => {
			const selector = 'it\'s:hover'
			const result = await generateTsCodegenContent(makeCtxWithSelectors(selector))
			// JSON.stringify does not escape single quotes
			expect(result)
				.toContain(`Selector: ${JSON.stringify(selector)}`)
		})

		it('should handle multiple selectors where some have special characters', async () => {
			const selectors = ['[attr="val"]', 'back\\slash', 'plain']
			const result = await generateTsCodegenContent(makeCtxWithSelectors(...selectors))
			for (const s of selectors) {
				expect(result)
					.toContain(JSON.stringify(s))
			}
		})
	})

	describe('with @layer support', () => {
		beforeEach(() => {
			vi.clearAllMocks()
		})

		it('should include Layer in Autocomplete when layers is configured', async () => {
			const ctx = createMockCtxForTsCodegen({ layers: { preflights: 0, atomic: 1 } })
			const result = await generateTsCodegenContent(ctx)
			expect(result)
				.toContain('Layer:')
			expect(result)
				.toContain('"preflights"')
			expect(result)
				.toContain('"atomic"')
		})

		it('should generate Layer as union type of layer names sorted by priority', async () => {
			const ctx = createMockCtxForTsCodegen({ layers: { preflights: 0, atomic: 1 } })
			const result = await generateTsCodegenContent(ctx)
			expect(result)
				.toContain('Layer: "preflights" | "atomic"')
		})

		it('should include Layer inside the Autocomplete type block', async () => {
			const ctx = createMockCtxForTsCodegen({ layers: { preflights: 0, atomic: 1 } })
			const result = await generateTsCodegenContent(ctx)
			const autocompleteStart = result.indexOf('DefineAutocomplete<{')
			const autocompleteEnd = result.indexOf('}>', autocompleteStart)
			const layerIndex = result.indexOf('Layer:', autocompleteStart)
			expect(layerIndex)
				.toBeGreaterThan(autocompleteStart)
			expect(layerIndex)
				.toBeLessThan(autocompleteEnd)
		})

		it('should generate Layer as never when layers is not configured', async () => {
			const ctx = createMockCtxForTsCodegen()
			const result = await generateTsCodegenContent(ctx)
			expect(result)
				.toContain('Layer: never')
		})

		it('should generate Layer containing all configured layer names when three layers are configured', async () => {
			const ctx = createMockCtxForTsCodegen({ layers: { base: 0, components: 1, utilities: 2 } })
			const result = await generateTsCodegenContent(ctx)
			expect(result)
				.toContain('Layer: "base" | "components" | "utilities"')
		})
	})
})

import type { IntegrationContext } from './types'
import { describe, expect, it, vi } from 'vitest'
import { generateTsCodegenContent } from './tsCodegen'

function createMockCtx(overrides: Partial<Pick<IntegrationContext, 'currentPackageName' | 'fnName' | 'transformedFormat' | 'hasVue' | 'engine' | 'usages'>> = {}): IntegrationContext {
	return {
		currentPackageName: '@pikacss/core',
		fnName: 'pika',
		transformedFormat: 'string',
		hasVue: false,
		engine: {
			config: {
				autocomplete: {
					selectors: new Set(['hover']),
					styleItemStrings: new Set(['flex-center']),
					extraProperties: new Set(['__important']),
					extraCssProperties: new Set(['--color']),
					properties: new Map([['__important', ['boolean']]]),
					cssProperties: new Map([['color', ['red', 'blue']]]),
				},
			},
			renderAtomicStyles: vi.fn()
				.mockResolvedValue('.a { color: red; }'),
		},
		usages: new Map(),
		...overrides,
	} as unknown as IntegrationContext
}

describe('generateTsCodegenContent', () => {
	it('should generate import statement with correct package name', async () => {
		const ctx = createMockCtx()
		const result = await generateTsCodegenContent(ctx)
		expect(result)
			.toContain(`// Auto-generated by @pikacss/core`)
		expect(result)
			.toContain(`import type { CSSProperty, CSSSelector, DefineAutocomplete, Properties, StyleDefinition, StyleItem } from '@pikacss/core'`)
	})

	it('should generate import statement with custom package name', async () => {
		const ctx = createMockCtx({ currentPackageName: '@pikacss/custom' })
		const result = await generateTsCodegenContent(ctx)
		expect(result)
			.toContain(`// Auto-generated by @pikacss/custom`)
		expect(result)
			.toContain(`from '@pikacss/custom'`)
	})

	it('should include Autocomplete type definition', async () => {
		const ctx = createMockCtx()
		const result = await generateTsCodegenContent(ctx)
		expect(result)
			.toContain('export type Autocomplete = DefineAutocomplete<{')
		expect(result)
			.toContain(`Selector: 'hover'`)
		expect(result)
			.toContain(`StyleItemString: 'flex-center'`)
		expect(result)
			.toContain(`ExtraProperty: '__important'`)
		expect(result)
			.toContain(`ExtraCssProperty: '--color'`)
		expect(result)
			.toContain(`PropertiesValue: { '__important': boolean }`)
		expect(result)
			.toContain(`CssPropertiesValue: { 'color': 'red' | 'blue' }`)
	})

	it('should generate Autocomplete with empty sets as never', async () => {
		const ctx = createMockCtx({
			engine: {
				config: {
					autocomplete: {
						selectors: new Set(),
						styleItemStrings: new Set(),
						extraProperties: new Set(),
						extraCssProperties: new Set(),
						properties: new Map(),
						cssProperties: new Map(),
					},
				},
				renderAtomicStyles: vi.fn()
					.mockResolvedValue(''),
			} as unknown as IntegrationContext['engine'],
		})
		const result = await generateTsCodegenContent(ctx)
		expect(result)
			.toContain('Selector: never')
		expect(result)
			.toContain('StyleItemString: never')
		expect(result)
			.toContain('ExtraProperty: never')
		expect(result)
			.toContain('ExtraCssProperty: never')
	})

	it('should generate StyleFn types for string format', async () => {
		const ctx = createMockCtx({ transformedFormat: 'string' })
		const result = await generateTsCodegenContent(ctx)
		expect(result)
			.toContain('type StyleFn_Normal = StyleFn_String')
		expect(result)
			.toContain('type StyleFn_Array = (...params: StyleItem[]) => string[]')
		expect(result)
			.toContain('type StyleFn_String = (...params: StyleItem[]) => string')
		expect(result)
			.toContain('type StyleFn_Inline = (...params: StyleItem[]) => void')
	})

	it('should generate StyleFn types for array format', async () => {
		const ctx = createMockCtx({ transformedFormat: 'array' })
		const result = await generateTsCodegenContent(ctx)
		expect(result)
			.toContain('type StyleFn_Normal = StyleFn_Array')
	})

	it('should generate StyleFn types for inline format', async () => {
		const ctx = createMockCtx({ transformedFormat: 'inline' })
		const result = await generateTsCodegenContent(ctx)
		expect(result)
			.toContain('type StyleFn_Normal = StyleFn_Inline')
	})

	it('should generate StyleFn with str, arr, inl accessors', async () => {
		const ctx = createMockCtx()
		const result = await generateTsCodegenContent(ctx)
		expect(result)
			.toContain('type StyleFn = StyleFn_Normal & {')
		expect(result)
			.toContain('str: StyleFn_String')
		expect(result)
			.toContain('arr: StyleFn_Array')
		expect(result)
			.toContain('inl: StyleFn_Inline')
	})

	it('should generate global declaration with fnName', async () => {
		const ctx = createMockCtx({ fnName: 'pika' })
		const result = await generateTsCodegenContent(ctx)
		expect(result)
			.toContain('declare global {')
		expect(result)
			.toContain('const pika: StyleFn')
		expect(result)
			.toContain('const pikap: StyleFnWithPreview')
	})

	it('should generate global declaration with custom fnName', async () => {
		const ctx = createMockCtx({ fnName: 'css' })
		const result = await generateTsCodegenContent(ctx)
		expect(result)
			.toContain('const css: StyleFn')
		expect(result)
			.toContain('const cssp: StyleFnWithPreview')
	})

	it('should omit Vue declaration when hasVue is false', async () => {
		const ctx = createMockCtx({ hasVue: false })
		const result = await generateTsCodegenContent(ctx)
		expect(result).not.toContain('declare module \'vue\'')
		expect(result).not.toContain('ComponentCustomProperties')
	})

	it('should generate Vue declaration when hasVue is true', async () => {
		const ctx = createMockCtx({ hasVue: true, fnName: 'pika' })
		const result = await generateTsCodegenContent(ctx)
		expect(result)
			.toContain('declare module \'vue\'')
		expect(result)
			.toContain('interface ComponentCustomProperties')
		expect(result)
			.toContain('pika: StyleFn')
		expect(result)
			.toContain('pikap: StyleFnWithPreview')
	})

	it('should generate PikaAugment module declaration', async () => {
		const ctx = createMockCtx()
		const result = await generateTsCodegenContent(ctx)
		expect(result)
			.toContain('declare module \'@pikacss/core\'')
		expect(result)
			.toContain('interface PikaAugment')
		expect(result)
			.toContain('Autocomplete: Autocomplete')
	})

	it('should generate PreviewOverloads with empty usages', async () => {
		const ctx = createMockCtx({ usages: new Map() })
		const result = await generateTsCodegenContent(ctx)
		expect(result)
			.toContain('interface PreviewOverloads<StyleFn extends (StyleFn_Array | StyleFn_String | StyleFn_Inline)>')
		expect(result)
			.toContain('fn(...params: Parameters<StyleFn>): ReturnType<StyleFn>')
	})

	it('should generate PreviewOverloads with usage records', async () => {
		const usages = new Map([
			['file.ts', [
				{
					atomicStyleIds: ['a1'],
					params: [{ color: 'red' }],
				},
			]],
		])
		const mockRenderAtomicStyles = vi.fn()
			.mockResolvedValue('.a { color: red; }')
		const ctx = createMockCtx({
			usages: usages as unknown as IntegrationContext['usages'],
			engine: {
				config: {
					autocomplete: {
						selectors: new Set(['hover']),
						styleItemStrings: new Set(['flex-center']),
						extraProperties: new Set(['__important']),
						extraCssProperties: new Set(['--color']),
						properties: new Map([['__important', ['boolean']]]),
						cssProperties: new Map([['color', ['red', 'blue']]]),
					},
				},
				renderAtomicStyles: mockRenderAtomicStyles,
			} as unknown as IntegrationContext['engine'],
		})
		const result = await generateTsCodegenContent(ctx)
		expect(mockRenderAtomicStyles)
			.toHaveBeenCalledWith(true, { atomicStyleIds: ['a1'], isPreview: true })
		expect(result)
			.toContain('PikaCSS Preview')
		expect(result)
			.toContain('type P0_0 =')
		expect(result)
			.toContain('fn(...params: [p0: P0_0]): ReturnType<StyleFn>')
	})

	it('should handle renderAtomicStyles errors gracefully', async () => {
		const usages = new Map([
			['file.ts', [
				{
					atomicStyleIds: ['err'],
					params: [{ color: 'bad' }],
				},
			]],
		])
		const mockRenderAtomicStyles = vi.fn()
			.mockRejectedValue(new Error('render error'))
		const ctx = createMockCtx({
			usages: usages as unknown as IntegrationContext['usages'],
			engine: {
				config: {
					autocomplete: {
						selectors: new Set(),
						styleItemStrings: new Set(),
						extraProperties: new Set(),
						extraCssProperties: new Set(),
						properties: new Map(),
						cssProperties: new Map(),
					},
				},
				renderAtomicStyles: mockRenderAtomicStyles,
			} as unknown as IntegrationContext['engine'],
		})
		// Should not throw even when renderAtomicStyles rejects
		const result = await generateTsCodegenContent(ctx)
		expect(result)
			.toContain('interface PreviewOverloads')
		// The failing usage should be skipped
		expect(result).not.toContain('type P0_0 =')
	})

	it('should generate multiple usage overloads', async () => {
		const usages = new Map([
			['file.ts', [
				{
					atomicStyleIds: ['a1'],
					params: [{ color: 'red' }],
				},
				{
					atomicStyleIds: ['a2'],
					params: [{ fontSize: '16px' }, { margin: '0' }],
				},
			]],
		])
		const mockRenderAtomicStyles = vi.fn()
			.mockResolvedValue('.x { display: flex; }')
		const ctx = createMockCtx({
			usages: usages as unknown as IntegrationContext['usages'],
			engine: {
				config: {
					autocomplete: {
						selectors: new Set(),
						styleItemStrings: new Set(),
						extraProperties: new Set(),
						extraCssProperties: new Set(),
						properties: new Map(),
						cssProperties: new Map(),
					},
				},
				renderAtomicStyles: mockRenderAtomicStyles,
			} as unknown as IntegrationContext['engine'],
		})
		const result = await generateTsCodegenContent(ctx)
		expect(result)
			.toContain('type P0_0 =')
		expect(result)
			.toContain('type P1_0 =')
		expect(result)
			.toContain('type P1_1 =')
		expect(result)
			.toContain('fn(...params: [p0: P0_0]): ReturnType<StyleFn>')
		expect(result)
			.toContain('fn(...params: [p0: P1_0, p1: P1_1]): ReturnType<StyleFn>')
	})
})
